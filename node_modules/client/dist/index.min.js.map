{"version":3,"file":"index.min.js","sources":["../src/index.ts"],"sourcesContent":["// packages/client/src/index.ts\r\n\r\n// Define a type for your custom message protocol (for TS)\r\nexport interface WebSocketMessage {\r\n    type: string;\r\n    timestamp?: number;\r\n    originalTimestamp?: number;\r\n    content?: string;\r\n    [key: string]: any; // Allow other properties\r\n}\r\n\r\n// Internal state and variables\r\nlet ws: WebSocket | null = null;\r\nlet currentUrl: string ;\r\nlet pingInterval:  number; // Use NodeJS.Timeout for clarity with setInterval\r\nconst eventListeners: { [key: string]: Function[] } = {}; // Simple custom event system\r\n\r\n// --- Internal Helper Functions ---\r\n\r\nfunction _dispatchEvent(eventName: string, detail?: any): void {\r\n    if (eventListeners[eventName]) {\r\n        eventListeners[eventName].forEach(callback => callback(detail));\r\n    }\r\n}\r\n\r\nfunction _handleIncomingMessage(message: string): void {\r\n    try {\r\n        const parsedMessage: WebSocketMessage = JSON.parse(message);\r\n        if (parsedMessage.type === 'pong') {\r\n            const latency = Date.now() - (parsedMessage.originalTimestamp || 0);\r\n            _dispatchEvent('pong', { latency, ...parsedMessage });\r\n        } else {\r\n            _dispatchEvent('message', parsedMessage); // Generic message event\r\n            _dispatchEvent(parsedMessage.type, parsedMessage); // Specific type event\r\n        }\r\n    } catch (e) {\r\n        console.error(\"WebSocketClient: Failed to parse incoming message:\", message, e);\r\n        _dispatchEvent('error', new Error(`Failed to parse message: ${message}`));\r\n    }\r\n}\r\n\r\nfunction _sendRaw(message: string): void {\r\n    if (ws && ws.readyState === WebSocket.OPEN) {\r\n        ws.send(message);\r\n    } else {\r\n        console.warn(\"WebSocketClient: WebSocket not open, cannot send raw message.\");\r\n        _dispatchEvent('error', new Error('WebSocket not open'));\r\n    }\r\n}\r\n\r\nfunction _sendPing(): void {\r\n    _sendRaw(JSON.stringify({ type: \"ping\", timestamp: Date.now() }));\r\n}\r\n\r\nfunction _startPingInterval(): void {\r\n    if (pingInterval) clearInterval(pingInterval);\r\n    pingInterval = setInterval(_sendPing, 5000); // Ping every 5 seconds\r\n}\r\n\r\nfunction _stopPingInterval(): void {\r\n    if (pingInterval) {\r\n        clearInterval(pingInterval);\r\n        pingInterval = 0;\r\n    }\r\n}\r\n\r\nfunction _reconnect(): void {\r\n    if (currentUrl) {\r\n        console.log(`WebSocketClient: Attempting to reconnect to ${currentUrl}...`);\r\n        _dispatchEvent('reconnecting', { url: currentUrl });\r\n        setTimeout(() => connect(currentUrl), 3000); // Try again in 3 seconds\r\n    }\r\n}\r\n\r\n// --- Public API Functions ---\r\n\r\n/**\r\n * Connects to the WebSocket server.\r\n * @param {string} url - The WebSocket server URL (ws:// or wss://)\r\n */\r\nexport function connect(url: string): void {\r\n    if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {\r\n        console.log(\"WebSocketClient: WebSocket already connected or connecting.\");\r\n        return;\r\n    }\r\n\r\n    currentUrl = url;\r\n    ws = new WebSocket(url);\r\n\r\n    ws.onopen = () => {\r\n        console.log(\"WebSocketClient: Connection opened.\");\r\n        _startPingInterval();\r\n        _dispatchEvent('connected', { url });\r\n    };\r\n\r\n    ws.onmessage = (event) => {\r\n        _handleIncomingMessage(event.data.toString());\r\n    };\r\n\r\n    ws.onclose = (event) => {\r\n        console.log(\"WebSocketClient: Connection closed.\", event);\r\n        _stopPingInterval();\r\n        _dispatchEvent('disconnected', { code: event.code, reason: event.reason });\r\n        _reconnect();\r\n    };\r\n\r\n    ws.onerror = (event) => {\r\n        console.error(\"WebSocketClient: Error:\", event);\r\n        _dispatchEvent('error', event);\r\n        if (ws && ws.readyState === WebSocket.CLOSED) {\r\n            _reconnect(); // Attempt reconnect on error if already closed\r\n        }\r\n    };\r\n}\r\n\r\n/**\r\n * Sends a structured message to the WebSocket server.\r\n * Messages are automatically JSON.stringify'd.\r\n * @param {WebSocketMessage} messageData - The data object to send. Must have a 'type' property.\r\n */\r\nexport function send(messageData: WebSocketMessage): void {\r\n    if (typeof messageData !== 'object' || messageData === null || typeof messageData.type === 'undefined') {\r\n        console.error(\"WebSocketClient: Message must be an object with a 'type' property.\");\r\n        _dispatchEvent('error', new Error('Invalid message format for send'));\r\n        return;\r\n    }\r\n    _sendRaw(JSON.stringify(messageData));\r\n}\r\n\r\n/**\r\n * Disconnects from the WebSocket server.\r\n */\r\nexport function disconnect(): void {\r\n    if (ws && ws.readyState === WebSocket.OPEN) {\r\n        ws.close(1000, 'Client explicitly disconnected');\r\n        console.log('WebSocketClient: Explicitly closing connection.');\r\n        _stopPingInterval();\r\n        ws = null;\r\n        currentUrl = \"\";\r\n        _dispatchEvent('disconnected', { code: 1000, reason: 'Explicitly disconnected' });\r\n    } else {\r\n        console.warn(\"WebSocketClient: WebSocket is not open to disconnect.\");\r\n    }\r\n}\r\n\r\n/**\r\n * Checks if the WebSocket is currently connected.\r\n * @returns {boolean} True if connected, false otherwise.\r\n */\r\nexport function isConnected(): boolean {\r\n    return ws !== null && ws.readyState === WebSocket.OPEN;\r\n}\r\n\r\n/**\r\n * Subscribes a callback to a specific WebSocket event.\r\n * Events: 'connected', 'disconnected', 'reconnecting', 'error', 'message', 'pong',\r\n * and any custom message.type from the server (e.g., 'chatMessage').\r\n * @param {string} eventName - The name of the event to subscribe to.\r\n * @param {Function} callback - The callback function to execute when the event fires.\r\n */\r\nexport function on(eventName: string, callback: Function): void {\r\n    if (!eventListeners[eventName]) {\r\n        eventListeners[eventName] = [];\r\n    }\r\n    eventListeners[eventName].push(callback);\r\n}\r\n\r\n/**\r\n * Unsubscribes a callback from a specific WebSocket event.\r\n * @param {string} eventName - The name of the event to unsubscribe from.\r\n * @param {Function} callback - The callback function to remove.\r\n */\r\nexport function off(eventName: string, callback: Function): void {\r\n    if (eventListeners[eventName]) {\r\n        eventListeners[eventName] = eventListeners[eventName].filter(cb => cb !== callback);\r\n    }\r\n}"],"names":["currentUrl","pingInterval","ws","eventListeners","_dispatchEvent","eventName","detail","forEach","callback","_sendRaw","message","readyState","WebSocket","OPEN","send","console","warn","Error","_sendPing","JSON","stringify","type","timestamp","Date","now","_stopPingInterval","clearInterval","_reconnect","log","url","setTimeout","connect","CONNECTING","onopen","setInterval","onmessage","event","parsedMessage","parse","latency","originalTimestamp","e","error","_handleIncomingMessage","data","toString","onclose","code","reason","onerror","CLOSED","close","filter","cb","push","messageData"],"mappings":"aAYA,IACIA,EACAC,EAFAC,EAAuB,KAG3B,MAAMC,EAAgD,CAAA,EAItD,SAASC,EAAeC,EAAmBC,GACnCH,EAAeE,IACfF,EAAeE,GAAWE,QAAQC,GAAYA,EAASF,GAE/D,CAkBA,SAASG,EAASC,GACVR,GAAMA,EAAGS,aAAeC,UAAUC,KAClCX,EAAGY,KAAKJ,IAERK,QAAQC,KAAK,iEACbZ,EAAe,QAAS,IAAIa,MAAM,uBAE1C,CAEA,SAASC,IACLT,EAASU,KAAKC,UAAU,CAAEC,KAAM,OAAQC,UAAWC,KAAKC,QAC5D,CAOA,SAASC,IACDxB,IACAyB,cAAczB,GACdA,EAAe,EAEvB,CAEA,SAAS0B,IACD3B,IACAe,QAAQa,IAAI,+CAA+C5B,QAC3DI,EAAe,eAAgB,CAAEyB,IAAK7B,IACtC8B,WAAW,IAAMC,EAAQ/B,GAAa,KAE9C,CAQM,SAAU+B,EAAQF,IAChB3B,GAAOA,EAAGS,aAAeC,UAAUC,MAAQX,EAAGS,aAAeC,UAAUoB,YAK3EhC,EAAa6B,EACb3B,EAAK,IAAIU,UAAUiB,GAEnB3B,EAAG+B,OAAS,KACRlB,QAAQa,IAAI,uCAnCZ3B,GAAcyB,cAAczB,GAChCA,EAAeiC,YAAYhB,EAAW,KAoClCd,EAAe,YAAa,CAAEyB,SAGlC3B,EAAGiC,UAAaC,KAtEpB,SAAgC1B,GAC5B,IACI,MAAM2B,EAAkClB,KAAKmB,MAAM5B,GACxB,SAAvB2B,EAAchB,KAEdjB,EAAe,OAAQ,CAAEmC,QADThB,KAAKC,OAASa,EAAcG,mBAAqB,MAC5BH,KAErCjC,EAAe,UAAWiC,GAC1BjC,EAAeiC,EAAchB,KAAMgB,GAE3C,CAAE,MAAOI,GACL1B,QAAQ2B,MAAM,qDAAsDhC,EAAS+B,GAC7ErC,EAAe,QAAS,IAAIa,MAAM,4BAA4BP,KAClE,CACJ,CAyDQiC,CAAuBP,EAAMQ,KAAKC,aAGtC3C,EAAG4C,QAAWV,IACVrB,QAAQa,IAAI,sCAAuCQ,GACnDX,IACArB,EAAe,eAAgB,CAAE2C,KAAMX,EAAMW,KAAMC,OAAQZ,EAAMY,SACjErB,KAGJzB,EAAG+C,QAAWb,IACVrB,QAAQ2B,MAAM,0BAA2BN,GACzChC,EAAe,QAASgC,GACpBlC,GAAMA,EAAGS,aAAeC,UAAUsC,QAClCvB,MA5BJZ,QAAQa,IAAI,8DA+BpB,iDAoBQ1B,GAAMA,EAAGS,aAAeC,UAAUC,MAClCX,EAAGiD,MAAM,IAAM,kCACfpC,QAAQa,IAAI,mDACZH,IACAvB,EAAK,KACLF,EAAa,GACbI,EAAe,eAAgB,CAAE2C,KAAM,IAAMC,OAAQ,6BAErDjC,QAAQC,KAAK,wDAErB,iCAOI,OAAc,OAAPd,GAAeA,EAAGS,aAAeC,UAAUC,IACtD,cAqBM,SAAcR,EAAmBG,GAC/BL,EAAeE,KACfF,EAAeE,GAAaF,EAAeE,GAAW+C,OAAOC,GAAMA,IAAO7C,GAElF,aAhBM,SAAaH,EAAmBG,GAC7BL,EAAeE,KAChBF,EAAeE,GAAa,IAEhCF,EAAeE,GAAWiD,KAAK9C,EACnC,eA7CM,SAAe+C,GACjB,GAA2B,iBAAhBA,GAA4C,OAAhBA,QAAoD,IAArBA,EAAYlC,KAG9E,OAFAN,QAAQ2B,MAAM,2EACdtC,EAAe,QAAS,IAAIa,MAAM,oCAGtCR,EAASU,KAAKC,UAAUmC,GAC5B"}